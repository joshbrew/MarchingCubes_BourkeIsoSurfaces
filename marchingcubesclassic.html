<!DOCTYPE html>
<!-- Joshua Brewster (MIT License) -->
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Paul Bourke Marching Cubes in JavaScript</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: row;
      background: #eee;
    }

    canvas {
      border: 1px solid #333;
      margin: 10px;
    }
  </style>
</head>

<body>
  <canvas id="pointCanvas"></canvas>
  <canvas id="meshCanvas"></canvas>

  <!-- THREE.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /* ------------------------------------------------------------------
       1) Utility: Generating a Random Sphere Point Set
          + Creating a 3D Scalar Field
    ------------------------------------------------------------------ */

    function getCellCenterValue(grid) {
      // Quick hack: average the 8 corner values
      // (A more accurate approach: sample the actual scalar field at the center)
      let sum = 0;
      for (let i = 0; i < 8; i++) {
        sum += grid.val[i];
      }
      return sum / 8;
    }


    // Generate random points on the surface of a sphere
    function generateSpherePoints(numPoints, center, radius) {
      const buf = new Float32Array(numPoints * 3);
      const cx = center.x, cy = center.y, cz = center.z;

      for (let i = 0, p = 0; i < numPoints; ++i, p += 3) {
        const u = Math.random();                   // 0‥1
        const v = Math.random();
        const theta = 2 * Math.PI * u;             // azimuth
        const phi = Math.acos(2 * v - 1);        // polar

        const sinPhi = Math.sin(phi);
        buf[p] = cx + radius * sinPhi * Math.cos(theta);
        buf[p + 1] = cy + radius * sinPhi * Math.sin(theta);
        buf[p + 2] = cz + radius * Math.cos(phi);
      }
      return buf;          // Float32Array [x0,y0,z0, x1,y1,z1 …]
    }

    // Create a scalar field on a grid in [0,1]^3 by summing metaballs
    function createScalarField(points, gridSize, k, eps = 0.0001) {
      const gx = gridSize.x, gy = gridSize.y, gz = gridSize.z;
      const invX = 1 / (gx - 1), invY = 1 / (gy - 1), invZ = 1 / (gz - 1);
      const buf = new Float32Array(gx * gy * gz);
      const idx = (x, y, z) =>
        z * (gx * gy)   // jump whole z–slices
        + y * gx        // then rows within that slice
        + x;           // then columns within that row

      /* radius where exp(‑k·r²) == eps  →  outside that sphere contribution < eps */
      const r = Math.sqrt(-Math.log(eps) / k);
      const gxStep = invX, gyStep = invY, gzStep = invZ;

      for (let p = 0; p < points.length; p += 3) {
        const px = points[p], py = points[p + 1], pz = points[p + 2];

        const ix0 = Math.max(0, Math.floor((px - r) / gxStep));
        const ix1 = Math.min(gx - 1, Math.ceil((px + r) / gxStep));
        const iy0 = Math.max(0, Math.floor((py - r) / gyStep));
        const iy1 = Math.min(gy - 1, Math.ceil((py + r) / gyStep));
        const iz0 = Math.max(0, Math.floor((pz - r) / gzStep));
        const iz1 = Math.min(gz - 1, Math.ceil((pz + r) / gzStep));

        for (let i = ix0; i <= ix1; ++i) {
          const dx = i * invX - px;
          for (let j = iy0; j <= iy1; ++j) {
            const dy = j * invY - py;
            for (let k_ = iz0; k_ <= iz1; ++k_) {
              const dz = k_ * invZ - pz;
              const dist2 = dx * dx + dy * dy + dz * dz;
              buf[idx(i, j, k_)] += Math.exp(-k * dist2);
            }
          }
        }
      }
      return { data: buf, idx };
    }
    /* =
    
        /* ------------------------------------------------------------------
           2) Paul Bourke’s Tables and Interpolation
        ------------------------------------------------------------------ */

    // The 256–entry edge table
    const edgeTable = new Int32Array([
      0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
      0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
      0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
      0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
      0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
      0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
      0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
      0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
      0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
      0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
      0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
      0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
      0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
      0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
      0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
      0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
      0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
      0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
      0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
      0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
      0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
      0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
      0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
      0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
      0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
      0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
      0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
      0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
      0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
      0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
      0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
      0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
    ]);


    // --- For brevity in this demo, we supply the **complete** triTable below:
    const triTableFull = [
      [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
      [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
      [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
      [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
      [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
      [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
      [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
      [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
      [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
      [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
      [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
      [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
      [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
      [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
      [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 0, 8, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
      [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
      [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
      [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
      [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
      [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
      [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
      [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
      [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
      [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
      [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
      [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
      [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
      [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
      [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
      [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
      [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
      [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
      [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
      [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
      [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
      [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
      [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
      [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
      [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
      [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
      [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
      [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
      [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
      [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
      [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
      [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
      [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
      [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
      [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
      [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
      [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
      [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
      [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
      [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
      [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
      [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
      [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
      [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
      [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
      [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
      [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
      [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
      [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
      [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
      [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
      [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
      [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
      [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
      [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
      [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
      [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
      [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
      [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
      [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
      [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
      [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
      [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
      [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
      [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
      [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
      [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
      [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
      [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
      [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
      [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
      [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
      [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
      [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
      [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
      [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
      [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
      [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
      [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
      [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
      [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
      [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
      [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
      [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
      [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
      [6, 8, 4, 6, 11, 8, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
      [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
      [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
      [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
      [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
      [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
      [8, 1, 3, 8, 4, 1, 4, 6, 1, 6, 10, 1, -1, -1, -1, -1],
      [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
      [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
      [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
      [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
      [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
      [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
      [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
      [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
      [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
      [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
      [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
      [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
      [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
      [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
      [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
      [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
      [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
      [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
      [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
      [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
      [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
      [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
      [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
      [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
      [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
      [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
      [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
      [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
      [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
      [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
      [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
      [10, 11, 7, 10, 7, 5, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
      [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
      [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
      [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
      [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
      [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
      [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
      [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
      [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
      [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
      [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
      [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
      [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
      [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
      [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
      [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
      [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
      [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
      [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
      [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
      [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
      [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
      [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
      [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
      [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
      [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
      [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
      [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
      [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
      [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
      [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
      [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
      [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
      [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
      [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
      [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
      [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
      [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
      [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
      [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
      [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
      [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
      [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
      [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
    ];
    /* We'll actually use triTableFull in the code below: */
    const triTableUsed = triTableFull;



    const CORNER_POS = [
      [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],
      [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]
    ];

    const EDGE2VERT = [
      [0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]
    ];

    // For face fans in the slow method:
    const FACE_EDGES = {
      bottom: [0, 1, 2, 3],
      top: [7, 6, 5, 4],
      front: [8, 9, 4, 0],
      back: [2, 10, 6, 11],
      left: [3, 11, 7, 8],
      right: [1, 5, 10, 9]
    };




    const marchingCubesComputeShader = `
/****************************************************************************** 
 * marching_cubes_brick.wgsl – one thread = one grid cell
 ******************************************************************************/

// ─── binds ────────────────────────────────────────────────────────────────
struct Uniforms {
  isolevel : f32,      //  0
  dx       : f32,      //  4
  dy       : f32,      //  8
  dz       : f32,      // 12   (global Z spacing)
  gx       : u32,      // 16   full GRID X count
  gy       : u32,      // 20   full GRID Y count
  gz       : u32,      // 24   brick DEPTH in Z
  zBase    : f32,      // 28   world-space Z offset of this brick
};
@group(0) @binding(0) var<uniform> uni : Uniforms;

@group(0) @binding(1) var<storage, read>  field   : array<f32>;
@group(0) @binding(2) var<storage, read>  edgeTab : array<u32>;
@group(0) @binding(3) var<storage, read>  triTab  : array<i32>;

struct VertBuf { data: array<vec4<f32>> };
@group(0) @binding(4) var<storage, read_write> verts : VertBuf;

struct Counter { cnt: atomic<u32> };
@group(0) @binding(5) var<storage, read_write> counter : Counter;

// ─── constant tables ─────────────────────────────────────────────────────
const OFF : array<vec3<u32>, 8> = array<vec3<u32>, 8>(
  vec3<u32>(0,0,0), vec3<u32>(1,0,0),
  vec3<u32>(1,1,0), vec3<u32>(0,1,0),
  vec3<u32>(0,0,1), vec3<u32>(1,0,1),
  vec3<u32>(1,1,1), vec3<u32>(0,1,1)
);

const E2C : array<vec2<u32>, 12> = array<vec2<u32>, 12>(
  vec2<u32>(0,1), vec2<u32>(1,2), vec2<u32>(2,3), vec2<u32>(3,0),
  vec2<u32>(4,5), vec2<u32>(5,6), vec2<u32>(6,7), vec2<u32>(7,4),
  vec2<u32>(0,4), vec2<u32>(1,5), vec2<u32>(2,6), vec2<u32>(3,7)
);

// ─── helpers ──────────────────────────────────────────────────────────────
// CPU   idx(x,y,z) = (x*gy + y)*gz + z
// brick fld(i,j,k) = (i*uni.gy + j)*uni.gz + k  ✔
fn fld(i: u32, j: u32, k: u32) -> u32 {
    return (i * uni.gy + j) * uni.gz + k;
}

fn mixPos(iso: f32, pA: vec3<f32>, vA: f32,
                     pB: vec3<f32>, vB: f32) -> vec3<f32> {
  return pA + ((iso - vA) / (vB - vA)) * (pB - pA);
}

// ─── main ─────────────────────────────────────────────────────────────────
@compute @workgroup_size(4,4,4)
fn cs(@builtin(global_invocation_id) gid: vec3<u32>) {
  // note: uni.gz is brick‐depth here
  if (gid.x >= uni.gx - 1u ||
      gid.y >= uni.gy - 1u ||
      gid.z >= uni.gz - 1u) {
    return;
  }

  // 1) sample corners
  var val : array<f32, 8>;
  var pos : array<vec3<f32>, 8>;
  for (var c = 0u; c < 8u; c = c + 1u) {
    let ic = gid + OFF[c];
    val[c] = field[fld(ic.x, ic.y, ic.z)];
    pos[c] = vec3<f32>(
      f32(ic.x) * uni.dx,
      f32(ic.y) * uni.dy,
      uni.zBase + f32(ic.z) * uni.dz
    );
  }

  // 2) classify cube
  var cube : u32 = 0u;
  for (var c = 0u; c < 8u; c = c + 1u) {
    if (val[c] < uni.isolevel) {
      cube |= (1u << c);
    }
  }
  let edges = edgeTab[cube];
  if (edges == 0u) { return; }

  // 3) interpolate edge‐verts
  var vtx : array<vec3<f32>, 12>;
  for (var e = 0u; e < 12u; e = e + 1u) {
    if ((edges & (1u << e)) != 0u) {
      let a = E2C[e].x;
      let b = E2C[e].y;
      vtx[e] = mixPos(uni.isolevel, pos[a], val[a], pos[b], val[b]);
    }
  }

  // 4) emit triangles
  var idx : u32 = 0u;
  loop {
    let a = triTab[cube * 16u + idx];
    if (a < 0) { break; }
    let b = triTab[cube * 16u + idx + 1u];
    let c = triTab[cube * 16u + idx + 2u];
    if (b < 0 || c < 0) { break; }

    let dst = atomicAdd(&counter.cnt, 3u);
    verts.data[dst    ] = vec4<f32>(vtx[a], 1.0);
    verts.data[dst + 1] = vec4<f32>(vtx[b], 1.0);
    verts.data[dst + 2] = vec4<f32>(vtx[c], 1.0);

    idx = idx + 3u;
  }
}

    `;

    /**
     * marchingCubesCompute
     * --------------------
     * @param {GPUDevice} device      – WebGPU device
     * @param {{x:number,y:number,z:number}} gridSize
     * @param {Float32Array} field    – gx*gy*gz scalar samples (row‑major)
     * @param {number} isolevel
     * @returns {GPUBuffer} vertexBuffer – contains vec4<f32> verts, ready for a
     *                                    vertex‑shader or mapAsync() read‑back
     */
    async function marchingCubesCompute(device, gridSize, field, isolevel) {
      const { x: gx, y: gy, z: gz } = gridSize;

      /* ---------- constant lookup tables – upload once -------------------- */
      const edgeTableU32 = Uint32Array.from(edgeTable, v => v >>> 0);
      const edgeBuf = gpuBufferFromArray(device, edgeTableU32);
      const triBuf = gpuBufferFromArray(device,
        new Int32Array(triTableUsed.flat())
      );
      /* ---------- compile pipeline --------------------------------------- */
      const shaderMod = device.createShaderModule({ code: marchingCubesComputeShader });
      const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: { module: shaderMod, entryPoint: 'cs' }
      });

      /* ---------- brick size --------------------------------------------- */
      const bytesPerSample = 4;                  // f32
      const planeBytes = gx * gy * bytesPerSample;
      const maxPlanes = Math.floor(device.limits.maxBufferSize / planeBytes);
      const brickDepth = Math.max(2, Math.min(maxPlanes, gz)); // ≥2 slices

      /* ---------- CPU‑side buffer for ALL bricks ------------------------- */
      const worstVerts = (gx - 1) * (gy - 1) * (gz - 1) * 15;
      const allVerts = new Float32Array(worstVerts * 4);
      let writePtr = 0;
      const idx = (x, y, z) =>
        z * (gx * gy)   // jump whole z–slices
        + y * gx        // then rows within that slice
        + x;           // then columns within that row

      /* ---------- loop over Z bricks ------------------------------------- */
      for (let z0 = 0; z0 < gz - 1; z0 += brickDepth - 1) {
        const z1 = Math.min(z0 + brickDepth, gz);
        const depth = z1 - z0;                 // slices in this brick
        const dz = 1 / (gz - 1);            // world‑space step
        const zBaseF = z0 * dz;                 // world‑space offset

        /* ---- create a packed sub‑field buffer --------------------------- */
        const subSamples = gx * gy * depth;
        const subField = new Float32Array(gx * gy * depth);
        let dst = 0;
        for (let x = 0; x < gx; ++x) {
          const sliceOff = x * gy * depth;
          for (let y = 0; y < gy; ++y) {
            const rowOff = sliceOff + y * depth;
            for (let kLocal = 0; kLocal < depth; ++kLocal) {
              const z = z0 + kLocal;
              subField[rowOff + kLocal] = field[idx(x, y, z)];
            }
          }
        }
        const fieldBuf = gpuBufferFromArray(device, subField);

        /* ---- per‑brick output & vertex counter -------------------------- */
        const maxBrickVerts = (gx - 1) * (gy - 1) * (depth - 1) * 15;
        const vertBuf = device.createBuffer({
          size: maxBrickVerts * 16,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
        });
        const counterBuf = gpuBufferFromArray(
          device, new Uint32Array([0]), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
        );

        /* ---- uniform block (32 bytes) ---------------------------------- */
        const uniU32 = new Uint32Array(8);             // 8 × 4 B == 32 B
        const uniF32 = new Float32Array(uniU32.buffer);

        uniF32[0] = isolevel;
        uniF32[1] = 1 / (gx - 1);
        uniF32[2] = 1 / (gy - 1);
        uniF32[3] = 1 / (gz - 1);
        uniU32[4] = gx;
        uniU32[5] = gy;
        uniU32[6] = depth;            // brick depth (gz in shader)
        uniF32[7] = zBaseF;           // world‑space offset

        const uniBuf = gpuBufferFromArray(device, uniU32, GPUBufferUsage.UNIFORM);

        /* ---- bind group ----------------------------------------------- */
        const bind = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: uniBuf } },
            { binding: 1, resource: { buffer: fieldBuf } },
            { binding: 2, resource: { buffer: edgeBuf } },
            { binding: 3, resource: { buffer: triBuf } },
            { binding: 4, resource: { buffer: vertBuf } },
            { binding: 5, resource: { buffer: counterBuf } },
          ]
        });

        /* ---- encode ---------------------------------------------------- */
        const cmd = device.createCommandEncoder();
        {
          const pass = cmd.beginComputePass();
          pass.setPipeline(pipeline);
          pass.setBindGroup(0, bind);
          pass.dispatchWorkgroups(
            Math.ceil((gx - 1) / 4),
            Math.ceil((gy - 1) / 4),
            Math.ceil((depth - 1) / 4)
          );
          pass.end();
        }

        /* ---- read back vertex count & data ----------------------------- */
        const cntRead = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });
        cmd.copyBufferToBuffer(counterBuf, 0, cntRead, 0, 4);

        const vertsRead = device.createBuffer({
          size: vertBuf.size,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });
        cmd.copyBufferToBuffer(vertBuf, 0, vertsRead, 0, vertBuf.size);

       
console.time("GPU March Turnaround (Excluding CPU)"); device.queue.submit([cmd.finish()]);
        await Promise.all([
          cntRead.mapAsync(GPUMapMode.READ),
          vertsRead.mapAsync(GPUMapMode.READ),
        ]);

        const nVert = new Uint32Array(cntRead.getMappedRange())[0];
        const brickV = new Float32Array(vertsRead.getMappedRange(), 0, nVert * 4);
        allVerts.set(brickV, writePtr);
        writePtr += brickV.length;

        cntRead.unmap();
        vertsRead.unmap();
      }
console.timeEnd("GPU March Turnaround (Excluding CPU)");
      /* ---------- final shrink & return -------------------------------- */
      return allVerts.subarray(0, writePtr);      // Float32Array of vec4<f32>
    }

    /* helper --------------------------------------------------------------- */
    function gpuBufferFromArray(device, typedArr, usage = GPUBufferUsage.STORAGE) {
      const buf = device.createBuffer({
        size: typedArr.byteLength,
        usage,
        mappedAtCreation: true,
      });
      new typedArr.constructor(buf.getMappedRange()).set(typedArr);
      buf.unmap();
      return buf;
    }




    /* ------------------------------------------------------------------
       3) Bourke's Vertex Interpolation & Polygonise in JS
    ------------------------------------------------------------------ */

    // Interpolate isosurface crossing on the edge between two vertices
    function vertexInterp(isolevel, p1, p2, val1, val2) {
      if (Math.abs(isolevel - val1) < 1e-5) return p1;
      if (Math.abs(isolevel - val2) < 1e-5) return p2;
      if (Math.abs(val1 - val2) < 1e-5) return p1;
      const mu = (isolevel - val1) / (val2 - val1);
      return new THREE.Vector3(
        p1.x + mu * (p2.x - p1.x),
        p1.y + mu * (p2.y - p1.y),
        p1.z + mu * (p2.z - p1.z)
      );
    }

    /**
 * grid: {
 *   p:   [ {x,y,z}, … 8 corner positions ],
 *   val: [ v0, … v7 ]  // 8 corner scalar values
 * }
 * edgeTable:         Uint16Array(256) → 12‑bit mask
 * triTableUsed:      Int8Array(256×16) → up to 5 tris per cell
 * vertexInterp(iso, pA, pB, vA, vB) → {x,y,z}
 */
    // ─── Pre‑allocations & constants ──────────────────────────────────────────
    const V12 = new Array(12);
    const BELOW8 = new Array(8);
    const AMBFACES = [];    // will hold face names
    const RING = [];    // reusable for each face
    const CPOS = { x: 0, y: 0, z: 0 };
    const FACE_EDGES_SETS = {
      bottom: new Set(FACE_EDGES.bottom),
      top: new Set(FACE_EDGES.top),
      front: new Set(FACE_EDGES.front),
      back: new Set(FACE_EDGES.back),
      left: new Set(FACE_EDGES.left),
      right: new Set(FACE_EDGES.right),
    };

    // ─── Reusable, in‑place polygoniser ────────────────────────────────────────
    function polygoniseWithCenterInto(
      cubeindex, edges, val,
      i, j, k, dx, dy, dz,
      iso, out, ptr
    ) {
      // 1) interpolate the 12 edge‑vertices into V12[]
      for (let e = 0; e < 12; ++e) {
        if ((edges & (1 << e)) === 0) {
          V12[e] = undefined;
          continue;
        }
        const [a, b] = EDGE2VERT[e];
        const mu = (iso - val[a]) / (val[b] - val[a]);

        // corner positions in world‑space:
        const pa = CORNER_POS[a], pb = CORNER_POS[b];
        const pax = (i + pa[0]) * dx, pay = (j + pa[1]) * dy, paz = (k + pa[2]) * dz;
        const pbx = (i + pb[0]) * dx, pby = (j + pb[1]) * dy, pbz = (k + pb[2]) * dz;

        V12[e] = {
          x: pax + mu * (pbx - pax),
          y: pay + mu * (pby - pay),
          z: paz + mu * (pbz - paz),
        };
      }

      // 2) cell‑center sample & pos into CPOS
      let cVal = 0;
      CPOS.x = CPOS.y = CPOS.z = 0;
      for (let c = 0; c < 8; ++c) {
        cVal += val[c];
        CPOS.x += (i + CORNER_POS[c][0]) * dx;
        CPOS.y += (j + CORNER_POS[c][1]) * dy;
        CPOS.z += (k + CORNER_POS[c][2]) * dz;
      }
      cVal /= 8;
      CPOS.x /= 8; CPOS.y /= 8; CPOS.z /= 8;

      // 3) detect ambiguous faces: fill BELOW8[], then AMBFACES[]
      for (let c = 0; c < 8; ++c) BELOW8[c] = (val[c] < iso);
      AMBFACES.length = 0;
      for (let face in FACE_EDGES) {
        // take any two diagonal corner indices to test
        const [e0, , e2] = FACE_EDGES[face];
        const c0 = EDGE2VERT[e0][0], c2 = EDGE2VERT[e2][1];
        if (BELOW8[c0] !== BELOW8[c2]) AMBFACES.push(face);
      }

      // 4) emit standard tris (skip those wholly on an ambiguous face)
      const tri = triTableUsed[cubeindex];
      triLoop:
      for (let t = 0; t < 16; t += 3) {
        const i0 = tri[t];
        if (i0 < 0) break;
        const i1 = tri[t + 1], i2 = tri[t + 2];

        for (let face of AMBFACES) {
          const fe = FACE_EDGES_SETS[face];
          if (fe.has(i0) && fe.has(i1) && fe.has(i2)) {
            // all three edges on this ambiguous face → skip
            continue triLoop;
          }
        }

        // emit the triangle
        [i0, i1, i2].forEach(ei => {
          const p = V12[ei];
          out[ptr++] = p.x;
          out[ptr++] = p.y;
          out[ptr++] = p.z;
        });
      }

      // 5) fan‑triangulate each ambiguous face around CPOS
      for (let face of AMBFACES) {
        RING.length = 0;
        for (let e of FACE_EDGES[face]) {
          if (V12[e] !== undefined) RING.push(e);
        }
        if (RING.length < 3) continue;

        for (let m = 0; m < RING.length; ++m) {
          const a = RING[m], b = RING[(m + 1) % RING.length];
          // V12[a], V12[b], CPOS
          [V12[a], V12[b], CPOS].forEach(p => {
            out[ptr++] = p.x;
            out[ptr++] = p.y;
            out[ptr++] = p.z;
          });
        }
      }

      return ptr;
    }




    /* ------------------------------------------------------------------
       4) The "marchingCubes" driver:
          Loops over the entire volume, building "grid cells" and
          calling polygonise() on each.
    ------------------------------------------------------------------ */
    /* ------------------------------------------------------------------
   ultra‑light marching cubes – no THREE.Vector3 allocations,
   writes vertices straight to a Float32Array
------------------------------------------------------------------ */


    function marchingCubes(fieldObj, gridSize, isolevel, useSlow = false) {
      const { data: F, idx } = fieldObj;
      const { x: gx, y: gy, z: gz } = gridSize;
      const dx = 1 / (gx - 1), dy = 1 / (gy - 1), dz = 1 / (gz - 1);

      // worst‑case floats: 5 tris×3 verts×3 coords per cell
      const maxFloats = (gx - 1) * (gy - 1) * (gz - 1) * 45;
      const out = new Float32Array(maxFloats);
      let ptr = 0;

      // one‑time small buffers
      const val = new Float32Array(8);
      const V = new Array(12);

      for (let i = 0; i < gx - 1; ++i) {
        const x0 = i * dx, x1 = (i + 1) * dx;
        for (let j = 0; j < gy - 1; ++j) {
          const y0 = j * dy, y1 = (j + 1) * dy;
          for (let k = 0; k < gz - 1; ++k) {
            const z0 = k * dz, z1 = (k + 1) * dz;

            // build cube mask + corner values
            let cubeindex = 0;
            for (let c = 0; c < 8; ++c) {
              const [di, dj, dk] = CORNER_POS[c];
              const cx = i + di, cy = j + dj, cz = k + dk;
              const s = F[idx(cx, cy, cz)];
              val[c] = s;
              if (s < isolevel) cubeindex |= 1 << c;
            }

            const edges = edgeTable[cubeindex];
            if (!edges) continue;

            // choose fast or slow
            if (useSlow) {
              ptr = polygoniseWithCenterInto(
                cubeindex, edges, val,
                i, j, k, dx, dy, dz, isolevel,
                out, ptr
              );
            } else {
              // fast inline: interpolate & emit
              for (let e = 0; e < 12; ++e) {
                if ((edges & (1 << e)) === 0) continue;
                const [a, b] = EDGE2VERT[e];
                const mu = (isolevel - val[a]) / (val[b] - val[a]);
                const ax = CORNER_POS[a][0] ? x1 : x0;
                const ay = CORNER_POS[a][1] ? y1 : y0;
                const az = CORNER_POS[a][2] ? z1 : z0;
                const bx = CORNER_POS[b][0] ? x1 : x0;
                const by = CORNER_POS[b][1] ? y1 : y0;
                const bz = CORNER_POS[b][2] ? z1 : z0;
                V[e] = {
                  x: ax + mu * (bx - ax),
                  y: ay + mu * (by - ay),
                  z: az + mu * (bz - az)
                };
              }
              const tri = triTableUsed[cubeindex];
              for (let t = 0; t < 16; t += 3) {
                const i0 = tri[t];
                if (i0 < 0) break;
                const i1 = tri[t + 1], i2 = tri[t + 2];
                // emit three verts
                [i0, i1, i2].forEach(iE => {
                  const p = V[iE];
                  out[ptr++] = p.x;
                  out[ptr++] = p.y;
                  out[ptr++] = p.z;
                });
              }
            }
          }
        }
      }

      return out.subarray(0, ptr);
    }
    /* ------------------------------------------------------------------
           5) Demonstration: Build a point cloud, build a field, run MC,
              then show in two side-by-side Three.js canvases
        ------------------------------------------------------------------ */
    //
    //   A) Set up some parameters
    //
    const gridSize = { x: 50, y: 50, z: 50 }; // 50^3 sampling
    const numPoints = 15000;                     // # sphere points
    const sphereCenter = new THREE.Vector3(0.5, 0.5, 0.5);
    const sphereRadius = 0.3;
    const isolevel = 0.5; // chosen isosurface cutoff
    const k = 200;        // falloff for Gaussian/metaball

    //
    //   B) Generate random points on a sphere surface
    //      Then create the scalar field in [0..1]^3
    //
    console.time("Initializing data for MarchingCubes");
    const points = generateSpherePoints(numPoints, sphereCenter, sphereRadius);
    const field = createScalarField(points, gridSize, k);
    console.timeEnd("Initializing data for MarchingCubes");

    // Polygonise the entire field:
    console.time("MarchingCubes");
    const verts = marchingCubes(field, gridSize, isolevel);
    console.timeEnd("MarchingCubes");

    console.time("MarchingCubesSlow");
    const verts2 = marchingCubes(field, gridSize, isolevel, true);
    console.timeEnd("MarchingCubesSlow");

    const gpuMarch = async () => {
      const adapter = await navigator.gpu.requestAdapter();
      const device = await adapter.requestDevice();

      console.time('GPU march');
      const vertices = await marchingCubesCompute(
        device, gridSize, field.data, isolevel
      );
      console.timeEnd('GPU march');   // <<–– typically < 1 ms on a laptop dGPU

      //console.log(vertices);

      return vertices;
    }



    async function renderFinal(vertices) {
      // Build a BufferGeometry from the float array
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.computeVertexNormals(); // for shading

      /* ------------------------------------------------------------------
         6) Minimal Setup of Two Scenes (Points + Isosurface)
      ------------------------------------------------------------------ */
      let pointScene, meshScene, pointCamera, meshCamera, pointRenderer, meshRenderer;

      function initPointScene() {
        const canvas = document.getElementById('pointCanvas');
        pointRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        pointRenderer.setSize(window.innerWidth / 2, window.innerHeight);
        pointScene = new THREE.Scene();
        pointScene.background = new THREE.Color(0xeeeeee);

        pointCamera = new THREE.PerspectiveCamera(45, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);
        pointCamera.position.set(0.5, 0.5, 2);
        pointScene.add(pointCamera);

        // Show the random sphere points as a red point cloud
        const pGeom = new THREE.BufferGeometry();
        pGeom.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
        const pMat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.01 });
        const pCloud = new THREE.Points(pGeom, pMat);
        pointScene.add(pCloud);

        pointScene.add(new THREE.AmbientLight(0x888888));
      }

      function initMeshScene() {
        const canvas = document.getElementById('meshCanvas');
        meshRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        meshRenderer.setSize(window.innerWidth / 2, window.innerHeight);
        meshScene = new THREE.Scene();
        meshScene.background = new THREE.Color(0xeeeeee);

        meshCamera = new THREE.PerspectiveCamera(45, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);
        meshCamera.position.set(2, 0.5, 0.5);
        meshScene.add(meshCamera);

        // Create a material and mesh from the geometry
        const mat = new THREE.MeshStandardMaterial({
          color: 0x156289,
          side: THREE.DoubleSide,
          flatShading: false
        });
        const mesh = new THREE.Mesh(geometry, mat);
        meshScene.add(mesh);

        // Basic lighting
        meshScene.add(new THREE.AmbientLight(0x666666));
        const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dLight.position.set(1, 1, 1);
        meshScene.add(dLight);
      }

      function animate(t) {
        requestAnimationFrame(animate);
        // Optionally rotate the point cloud scene
        pointScene.rotation.y += 0.005;
        pointRenderer.render(pointScene, pointCamera);

        // Slowly orbit the mesh camera
        const orbitRadius = 2;
        const angle = 0.001 * t;
        meshCamera.position.x = sphereCenter.x + orbitRadius * Math.cos(angle);
        meshCamera.position.z = sphereCenter.z + orbitRadius * Math.sin(angle);
        meshCamera.lookAt(sphereCenter);

        meshRenderer.render(meshScene, meshCamera);
      }

      // Set it all up!
      initPointScene();
      initMeshScene();
      animate();

      // Ensure we handle window resizing
      window.addEventListener('resize', () => {
        const w = window.innerWidth / 2;
        const h = window.innerHeight;
        pointRenderer.setSize(w, h);
        pointCamera.aspect = w / h;
        pointCamera.updateProjectionMatrix();

        meshRenderer.setSize(w, h);
        meshCamera.aspect = w / h;
        meshCamera.updateProjectionMatrix();
      });



    }
    
    async function renderFinalGPU(vertices) {
  // vertices arrives as [x,y,z,w,  x,y,z,w,  …]
  // we need plain [x,y,z,  x,y,z, …] for Three.js
  const nVerts = vertices.length / 4;
  const positions = new Float32Array(nVerts * 3);

  for (let i = 0, j = 0; i < vertices.length; i += 4, j += 3) {
    positions[j]   = vertices[i];
    positions[j+1] = vertices[i+1];
    positions[j+2] = vertices[i+2];
  }

  // build BufferGeometry from 3-component positions
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute(
    'position',
    new THREE.BufferAttribute(positions, 3)
  );
  geometry.computeVertexNormals();

  /* ------------------------------------------------------------------
     6) Minimal Setup of Two Scenes (Points + Isosurface)
  ------------------------------------------------------------------ */
  let pointScene, meshScene, pointCamera, meshCamera, pointRenderer, meshRenderer;

  function initPointScene() {
    const canvas = document.getElementById('pointCanvas');
    pointRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    pointRenderer.setSize(window.innerWidth / 2, window.innerHeight);
    pointScene = new THREE.Scene();
    pointScene.background = new THREE.Color(0xeeeeee);

    pointCamera = new THREE.PerspectiveCamera(
      45,
      (window.innerWidth / 2) / window.innerHeight,
      0.1, 1000
    );
    pointCamera.position.set(0.5, 0.5, 2);
    pointScene.add(pointCamera);

    // red point cloud
    const pGeom = new THREE.BufferGeometry();
    pGeom.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
    const pMat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.01 });
    pointScene.add(new THREE.Points(pGeom, pMat));
    pointScene.add(new THREE.AmbientLight(0x888888));
  }

  function initMeshScene() {
    const canvas = document.getElementById('meshCanvas');
    meshRenderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    meshRenderer.setSize(window.innerWidth / 2, window.innerHeight);
    meshScene = new THREE.Scene();
    meshScene.background = new THREE.Color(0xeeeeee);

    meshCamera = new THREE.PerspectiveCamera(
      45,
      (window.innerWidth / 2) / window.innerHeight,
      0.1, 1000
    );
    meshCamera.position.set(2, 0.5, 0.5);
    meshScene.add(meshCamera);

    const mat = new THREE.MeshStandardMaterial({
      color: 0x156289,
      side: THREE.DoubleSide,
      flatShading: false
    });
    const mesh = new THREE.Mesh(geometry, mat);
    meshScene.add(mesh);

    meshScene.add(new THREE.AmbientLight(0x666666));
    const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dLight.position.set(1, 1, 1);
    meshScene.add(dLight);
  }

  function animate(t) {
    requestAnimationFrame(animate);
    pointScene.rotation.y += 0.005;
    pointRenderer.render(pointScene, pointCamera);

    const orbitRadius = 2;
    const angle = 0.001 * t;
    meshCamera.position.x = sphereCenter.x + orbitRadius * Math.cos(angle);
    meshCamera.position.z = sphereCenter.z + orbitRadius * Math.sin(angle);
    meshCamera.lookAt(sphereCenter);
    meshRenderer.render(meshScene, meshCamera);
  }

  initPointScene();
  initMeshScene();
  animate();

  window.addEventListener('resize', () => {
    const w = window.innerWidth / 2;
    const h = window.innerHeight;
    pointRenderer.setSize(w, h);
    pointCamera.aspect = w / h;
    pointCamera.updateProjectionMatrix();
    meshRenderer.setSize(w, h);
    meshCamera.aspect = w / h;
    meshCamera.updateProjectionMatrix();
  });
}

    //renderFinal(verts2);

    gpuMarch().then(renderFinalGPU);


  </script>
</body>

</html> 